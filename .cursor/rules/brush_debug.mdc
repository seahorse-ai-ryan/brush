---
description: Debugging workflows and tools for Brush
globs: 
alwaysApply: false
---
# Brush Debugging Workflow

## Web Application Debugging Process

When debugging Brush web applications, follow this structured process:

### 1. Clear Bug Identification

Before attempting any fixes, you MUST:

- Analyze error patterns in compilation output, runtime logs, and browser console
- Form a clear hypothesis about the root cause
- Document the exact error messages
- Identify which files need modifications
- Provide a concise description of the expected vs. actual behavior

Example bug identification format:
```
Bug identification:
- Issue: [Short description of the bug]
- Error messages: [Specific error messages, including line numbers if available]
- Affected files: [List of files that need modification]
- Environment: [Web/WASM, Chrome browser, etc.]
- Reproduction steps: [How to trigger the bug]
```

### 2. Root Cause Analysis

After identifying the bug, perform thorough analysis:

- Determine if the issue is platform-specific (web vs. desktop)
- Identify specific component(s) affected (UI, rendering, data management, etc.)
- Examine data flow leading to the error
- Check for similar patterns in previously fixed issues

Document your analysis:
```
Root cause analysis:
- Suspected cause: [Why the bug is occurring]
- Evidence: [What in the code/logs supports this]
- Related patterns: [Similar issues seen before]
- System impact: [Other components affected]
```

### 3. Solution Strategy

Before implementing changes, explain:

- The approach you'll take to fix the issue
- Specific code changes required
- Any potential side effects or risks
- How you'll verify the fix works

### 4. Implementation and Testing

When implementing changes:

1. Make focused, incremental changes to one file at a time
2. Provide clear explanations of what each change does
3. After code changes, automatically reload the browser:
   ```bash
   cd <project_root> && curl -X POST http://localhost:8080/_trunk/reload
   ```
4. Check console logs for errors or warnings
5. Verify the fix works as expected

### 5. Documentation and Knowledge Capture

After resolving the issue:

1. Document the fix in the code with clear comments
2. Update relevant files in the /docs directory
3. Capture lessons learned in brush_lessons.mdc
4. Ensure the fix works across all relevant platforms

## Advanced Debugging Techniques

### MCP Server Configuration

> **Important**: The MCP server must be configured properly in Cursor first:
> 1. Create `.cursor/mcp.json` with content:
>    ```json
>    {
>      "servers": [
>        {
>          "name": "browser-tools",
>          "type": "command", 
>          "command": "npx @agentdeskai/browser-tools-mcp@1.2.0"
>        }
>      ]
>    }
>    ```
> 2. Restart Cursor for the changes to take effect
> 3. Make sure the BrowserTools Chrome extension is installed
> 4. Open the Chrome Developer Tools in the tab you want to debug

### Monitor Console Logs

To see all console logs in real-time:
```bash
curl -s http://localhost:3025/console-logs | jq .
```

### Filter for Specific Error Types

To focus on specific errors:
```bash
curl -s http://localhost:3025/console-logs | jq '.[] | select(.level=="error" and (.message | contains("filesystem")))'
```

### Specialized Debug Commands

For running in debug mode with performance metrics:
```bash
cd <project_root> && RUST_LOG=debug trunk serve
```

### Network Request Analysis

The MCP server captures network requests, allowing analysis of API calls and resource loading. To examine network activity:
```bash
curl -s http://localhost:3025/network-requests | jq .
```

### Memory Profiling

For memory issues, use the Chrome DevTools Memory tab:
1. Open DevTools > Memory tab
2. Take a heap snapshot
3. Look for large objects and leak patterns

## Platform-Specific Debugging

### WASM-Specific Debug Techniques

When debugging WASM-specific issues:

1. Use `#[cfg(target_arch = "wasm32")]` for web-specific code paths
2. Use `#[cfg(not(target_arch = "wasm32"))]` for native-only code
3. Add WASM-specific debug logging:
   ```rust
   #[cfg(target_arch = "wasm32")]
   {
       // Web-specific implementation
       utils::log_info("Running in web environment");
       // Add detailed debug logs
       utils::log_debug(&format!("Processing file: {:?}", file_path));
   }
   ```

4. Check for browser limitations, especially:
   - Filesystem operations (not available)
   - IndexedDB access (async/await patterns)
   - Memory constraints (chunked processing)

### Desktop/Native Debug Techniques

For desktop-specific issues:

1. Use environment variables for debugging:
   ```bash
   RUST_BACKTRACE=1 RUST_LOG=trace cargo run
   ```

2. Employ platform-specific tools:
   - Linux: valgrind, gdb
   - macOS: lldb, Instruments
   - Windows: Visual Studio debugger

## Safe Git Operations During Debugging

When using git with AI assistance during debugging:

1. **Accepting Changes in Cursor:**
   - Always hit "Accept All" in the Cursor UI before committing
   - Changes shown in Cursor are not saved to disk until accepted
   - Unsaved changes will not be included in git commits

2. **Commit Safety:**
   - AI should ask for explicit confirmation before git operations
   - AI should show `git status` before committing
   - AI should remind the developer to accept changes
   - Developer should verify committed changes match what's seen in the editor 
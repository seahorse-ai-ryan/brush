---
description: Debugging workflows and tools for Brush
globs: 
alwaysApply: false
---
# Brush Debugging Workflow

## Web Application Debugging Process

When debugging Brush web applications, follow this structured process:

### 1. Setup Development Environment

First, set up a proper debugging environment:

#### Start MCP Server for Console Logs

‚ö†Ô∏è **IMPORTANT**: Start the MCP server using a plain code block with triple backticks. DO NOT use the run_terminal_cmd tool.

```bash
cd <project_root> && (pkill -f "browser-tools-server" || true) && npx @agentdeskai/browser-tools-server@1.2.0 --port 3025
```

#### Start Trunk Server for Building

‚ö†Ô∏è **IMPORTANT**: Start the Trunk server using a plain code block with triple backticks. DO NOT use the run_terminal_cmd tool.

```bash
cd <project_root> && (pkill -f "trunk serve" || true) && trunk serve
```

#### Access the Application

Open in Chrome with DevTools and the BrowserTools extension active:
```
http://localhost:8080/
```

### 2. Clear Bug Identification

Before attempting any fixes, you MUST:

- Analyze error patterns in MCP console logs
- Form a clear hypothesis about the root cause
- Document the exact error messages
- Identify which files need modifications
- Provide a concise description of the expected vs. actual behavior

Example bug identification format:
```
Bug identification:
- Issue: [Short description of the bug]
- Error messages: [Specific error messages from MCP, including line numbers if available]
- Affected files: [List of files that need modification]
- Environment: [Web/WASM, Chrome browser, etc.]
- Reproduction steps: [How to trigger the bug]
```

### 3. Root Cause Analysis

After identifying the bug, perform thorough analysis:

- Determine if the issue is platform-specific (web vs. desktop)
- Identify specific component(s) affected (UI, rendering, data management, etc.)
- Examine data flow leading to the error
- Check for similar patterns in previously fixed issues

Document your analysis:
```
Root cause analysis:
- Suspected cause: [Why the bug is occurring]
- Evidence: [What in the code/logs supports this]
- Related patterns: [Similar issues seen before]
- System impact: [Other components affected]
```

### 4. Solution Strategy

Before implementing changes, explain:

- The approach you'll take to fix the issue
- Specific code changes required
- Any potential side effects or risks
- How you'll verify the fix works

### 5. Implementation and Testing

When implementing changes:

1. Make focused, incremental changes to one file at a time
2. Provide clear explanations of what each change does
3. View console logs in MCP to see if your changes fix the issue
4. Trunk will automatically rebuild and the browser will reload
5. Verify the fix works as expected through MCP logs

### 6. Documentation and Knowledge Capture

After resolving the issue:

1. Document the fix in the code with clear comments
2. Update relevant files in the /docs directory
3. Capture lessons learned in brush_lessons.mdc
4. Ensure the fix works across all relevant platforms

## Enhanced Debugging with MCP

### Using MCP Server for Console Logs

The MCP (Multi-Channel Protocol) server allows you to monitor browser console logs directly in the AI chat. To use it effectively:

1. Start the MCP server as described above
2. Start the Trunk server as described above 
3. Open Chrome with the BrowserTools extension active
4. Navigate to http://localhost:8080/
5. Open Chrome DevTools to activate the BrowserTools extension

Once set up, you can use natural language to access browser data:

- "What messages are in the console logs?" - Shows all console logs
- "Are there any errors in the console?" - Shows error logs only
- "Check network logs" - Shows successful network requests
- "Check network errors" - Shows failed network requests
- "Take a screenshot" - Captures the current browser view

Advantages of this approach:
- See browser console logs without switching windows
- Capture errors directly from WASM environment
- Observe runtime behavior without parsing complex logs
- Instantly validate if your code changes fixed the issue

### Enhanced Error Handling in Code

To better support debugging through MCP, implement these patterns:

1. Add detailed error logging in Rust/WASM code:
   ```rust
   #[cfg(target_arch = "wasm32")]
   {
       utils::log_debug(&format!("Processing file: {:?}", file_path));
       
       match process_file(file_path) {
           Ok(result) => utils::log_info(&format!("File processed successfully: {:?}", result)),
           Err(e) => utils::log_error(&format!("Failed to process file: {:?} - Error: {:?}", file_path, e))
       }
   }
   ```

2. Use custom panic hooks for better error reporting:
   ```rust
   #[cfg(target_arch = "wasm32")]
   pub fn set_panic_hook() {
       std::panic::set_hook(Box::new(|panic_info| {
           // Format a detailed panic message
           let message = format!("üö® PANIC: {}", panic_info);
           web_sys::console::error_1(&message.into());
       }));
   }
   ```

3. Add JavaScript error tracking to index.html:
   ```javascript
   window.onerror = function(msg, url, line, col, error) {
       console.error(`ERROR: ${msg} at ${url}:${line}:${col}`);
       // Display error on page
       document.getElementById('error-display').innerText = msg;
       return false;
   };
   ```

## Platform-Specific Debugging

### WASM-Specific Debug Techniques

When debugging WASM-specific issues:

1. Use `#[cfg(target_arch = "wasm32")]` for web-specific code paths
2. Use `#[cfg(not(target_arch = "wasm32"))]` for native-only code
3. Add WASM-specific debug logging:
   ```rust
   #[cfg(target_arch = "wasm32")]
   {
       // Web-specific implementation
       utils::log_info("Running in web environment");
       // Add detailed debug logs
       utils::log_debug(&format!("Processing file: {:?}", file_path));
   }
   ```

4. Check for browser limitations, especially:
   - Filesystem operations (not available)
   - IndexedDB access (async/await patterns)
   - Memory constraints (chunked processing)

### Desktop/Native Debug Techniques

For desktop-specific issues:

1. Use environment variables for debugging:
   ```bash
   RUST_BACKTRACE=1 RUST_LOG=trace cargo run
   ```

2. Employ platform-specific tools:
   - Linux: valgrind, gdb
   - macOS: lldb, Instruments
   - Windows: Visual Studio debugger

## Git Operation Guidelines

When assisting with git operations:

1. Always verify changes are accepted in the editor before suggesting git commands
2. Show current git status before suggesting commits
3. Confirm with the developer before executing git commit/push commands
4. Never assume changes are saved unless explicitly confirmed
5. Highlight which files will be included in commits 
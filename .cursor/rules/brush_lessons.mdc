---
description: Practical solutions, patterns, and lessons learned from Brush development
globs: ["**/*.rs"]
alwaysApply: true
---
<lessons_learned>
# UI Development
## Window Management
1. Problem: Window resizability issues
   - Symptoms: Windows only partially resizable, content not adapting
   - Solution: Use proper egui window configuration and layout
   ```rust
   // Good: Proper window setup
   Window::new("Title")
       .resizable(true)
       .min_width(280.0)
       .show(ctx, |ui| {
           ui.set_width(ui.available_width());
           ui.set_height(ui.available_height());
           
           ScrollArea::vertical()
               .auto_shrink([false, false])
               .show_viewport(ui, |ui, _viewport| {
                   // Content here
               });
       });
   ```

2. Problem: Window state persistence
   - Symptoms: Window sizes/positions not properly saved
   - Solution: Use egui's built-in memory system
   ```rust
   // Reset window states
   ctx.memory_mut(|mem| {
       mem.data.clear();
   });
   ```

## State Management
1. Problem: Borrow checker conflicts in UI
   - Symptoms: Multiple mutable borrows in closures
   - Solution: Use local variables and flags
   ```rust
   // Good: Local state pattern
   let mut local_state = self.state.clone();
   let mut should_process = false;
   
   if ui.button("Process").clicked() {
       should_process = true;
   }
   
   if should_process {
       self.process_data();
   }
   ```

2. Problem: Type mismatches with window responses
   - Symptoms: Expected bool, found Option<bool>
   - Solution: Proper pattern matching
   ```rust
   if let Some(inner_response) = &response {
       if let Some(close_clicked) = inner_response.inner {
           if close_clicked {
               self.open = false;
           }
       }
   }
   ```

# File Handling
1. Problem: File handle consumption
   - Symptoms: FileHandle becomes unusable after read
   - Solution: Extract needed information before reading
   ```rust
   // Good: Get info before consuming handle
   let file_name = file_handle.name().to_string();
   let file_size = file_handle.size();
   let contents = file_handle.read()?; // Handle consumed here
   ```

2. Problem: Cross-platform file dialogs
   - Symptoms: Different behavior on web vs desktop
   - Solution: Platform-specific implementations
   ```rust
   // Good: Platform-specific file handling
   #[cfg(target_arch = "wasm32")]
   fn show_file_dialog() -> Option<FileHandle> {
       // Web file picker implementation
   }

   #[cfg(not(target_arch = "wasm32"))]
   fn show_file_dialog() -> Option<FileHandle> {
       // Native file dialog implementation
   }
   ```

3. Problem: File type handling
   - Symptoms: Inconsistent processing of different file types
   - Solution: Type-based processing flow
   ```rust
   // Good: Type-specific processing
   fn process_file(path: &Path) -> Result<(), Error> {
       match path.extension().and_then(|s| s.to_str()) {
           Some("zip") => process_zip_file(path),
           Some("ply") => process_ply_file(path),
           Some(ext) => Err(Error::UnsupportedFormat(ext.to_string())),
           None => Err(Error::NoExtension),
       }
   }
   ```

# Performance Optimization
## Memory Management
1. Problem: WASM memory leaks
   - Symptoms: Growing memory usage in browser
   - Solution: Proper cleanup of WebGL contexts
   ```rust
   impl Drop for WebGLResource {
       fn drop(&mut self) {
           #[cfg(target_arch = "wasm32")]
           self.cleanup_webgl_context();
       }
   }
   ```

2. Problem: GPU resource management
   - Symptoms: Resource leaks, performance degradation
   - Solution: Use appropriate ownership patterns
   ```rust
   // Good: Shared ownership with cleanup
   struct GpuResource {
       buffer: Arc<Buffer>,
       texture: Arc<Texture>,
   }
   ```

# Cross-Platform Development
## Web Platform
1. Problem: File handling differences
   - Symptoms: File operations failing in web
   - Solution: Platform-specific implementations
   ```rust
   #[cfg(target_arch = "wasm32")]
   fn handle_file() {
       // Web-specific file handling
   }
   
   #[cfg(not(target_arch = "wasm32"))]
   fn handle_file() {
       // Native file handling
   }
   ```

2. Problem: Memory constraints
   - Symptoms: Out of memory in large operations
   - Solution: Chunked processing
   ```rust
   #[cfg(target_arch = "wasm32")]
   fn process_large_data(data: &[u8]) {
       for chunk in data.chunks(MAX_CHUNK_SIZE) {
           // Process chunk
       }
   }
   ```

# Graphics & Rendering
## Layout Issues
1. Problem: Incorrect space allocation
   - Symptoms: Components not filling space
   - Solution: Proper layout constraints
   ```rust
   ui.vertical(|ui| {
       ui.set_min_size(egui::vec2(ui.available_width(), ui.available_height()));
       // Content
   });
   ```

2. Problem: Scroll area behavior
   - Symptoms: Content collapsing
   - Solution: Configure auto-shrink
   ```rust
   ScrollArea::vertical()
       .auto_shrink([false, false])
       .show(ui, |ui| {
           // Content
       });
   ```

# JavaScript Integration
1. Problem: Event flag handling
   - Symptoms: Events not properly tracked
   - Solution: Clear flag management
   ```rust
   // Good: Event flag management
   let mut event_processed = false;
   if ui.button("Process").clicked() {
       event_processed = true;
   }
   if event_processed {
       self.handle_event();
   }
   ```

2. Problem: JSON formatting
   - Symptoms: Invalid JSON in web communication
   - Solution: Proper serialization
   ```rust
   // Good: JSON handling
   #[derive(Serialize, Deserialize)]
   struct WebMessage {
       event_type: String,
       data: Value,
   }

   fn send_to_js(msg: &WebMessage) {
       #[cfg(target_arch = "wasm32")]
       web_sys::window()
           .unwrap()
           .dispatch_event(&msg.into_event())
           .unwrap();
   }
   ```

# Best Practices
1. Debug Logging:
   ```rust
   // Good: Comprehensive debug logging
   println!("WINDOW DEBUG: State change {} -> {}", old_state, new_state);
   println!("WINDOW DEBUG: Available size: {:?}", size);
   println!("WINDOW DEBUG: Response: {:?}", response);
   ```

2. Error Handling:
   ```rust
   // Good: Error handling pattern
   fn process() -> Result<(), AppError> {
       let data = load_data().context("Failed to load data")?;
       process_data(&data).context("Failed to process data")?;
       Ok(())
   }
   ```

3. Testing:
   ```rust
   #[cfg(test)]
   mod tests {
       #[test]
       fn test_component() {
           // Setup
           let mut component = Component::new();
           
           // Test
           component.update();
           
           // Verify
           assert_eq!(component.state, expected_state);
       }
   }
   ```
</lessons_learned> 